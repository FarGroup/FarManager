<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>

<head>
<link REV="made" href="mailto:rampitec@tu.spb.ru">
<meta NAME="Author" content="Stanislav V. Mekhanoshin">
<meta NAME="description" CONTENT="ECTL_GETSTRING работает слишком медленно...">
<link rel="stylesheet" type="text/css" href="../../styles/styles.css">
<script language="JavaScript" src='../links.js' type="text/javascript"></script>
<title>ECTL_GETSTRING работает слишком медленно...</title>
<meta http-equiv="Content-Type" Content="text/html; charset=Windows-1251">
</head>

<body>
<a name="top"></a>
<h1>ECTL_GETSTRING работает слишком медленно</h1>
<div class=navbar>
<a href="../index.html">главная</a> |
<a href="index.html">статьи</a>
</div>
<div align=right>
<code>Stanislav V. Mekhanoshin <a
href="mailto:Stanislav%20V%2E%20Mekhanoshin%20<rampitec@tu.spb.ru>?subject=Articles"><img
src="../../images/email.gif" border="0" alt="[rampitec@tu.spb.ru]" width="16" height="16"
align="middle">rampitec@tu.spb.ru</a>
</code></div>
<hr color="#003399">


<p class=plain>
Предположим, что плагину нужно пройтись последовательно по большому
количеству строк редактора. В моем случае, плагин <a target="_blank"
href="http://plugring.farmanager.com/cgi-bin/downld.cgi?Draw=List&Select=PlugIn&SelectPlugIn=171">Incremental Search</a>
осуществлял поиск подстроки в редакторе. Первая мысль, которая приходит в
голову - сделать последовательный перебор строк примерно так:</P>
<PRE class=code>{
    struct EditorGetString egs;
    struct EditorSetPosition esp;
    struct EditorInfo ei;

    Info.EditorControl(ECTL_GETINFO,&ei);

    for( egs.StringNumber=ei.CurLine;
         egs.StringNumber &lt; ei.TotalLines;
         egs.StringNumber++ )
    {
        Info.EditorControl(ECTL_GETSTRING,&egs);
        if( process( egs.StringText, egs.StringLength ) ){
            esp.CurLine=egs.StringNumber;
            esp.CurPos=-1;
            esp.CurTabPos=-1;
            esp.TopScreenLine=-1;
            esp.LeftPos=-1;
            esp.OverType=-1;
            Info.EditorControl(ECTL_SETPOSITION,&esp);
            return TRUE; // Успех, установили текущую строку.
        }
    }
    return FALSE; // Неуспех, просто вернемся. В редакторе ничего не
                  // изменилось.
}</PRE>
<p class=plain>
Однако, написав таким образом, я обнаружил, что код обработки
строки (собственно, функция <EM>process()</EM>), работает на два порядка
быстрее, чем весь этот цикл в целом. Т.е. процедура взятия строки по номеру
поглощает ~99% времени.</P>

<p class=plain>
Код был переделан по совету, предложенному ER (не только мне,
также поступил в плагине <a target="_blank" href="http://plugring.farmanager.com/cgi-bin/downld.cgi?Draw=List&Select=PlugIn&SelectPlugIn=93">EditCompletition</a>,
Андрей Третьяков).
Суть совета заключается в том, чтобы брать строку не по номеру, а
всегда текущую (-1). Т.е. заменить <a href="../service_functions/editorcontrol.html#ECTL_GETSTRING">ECTL_GETSTRING</a> с номером строки на пару
<a href="../service_functions/editorcontrol.html#ECTL_SETPOSITION">ECTL_SETPOSITION</a> с номером строки и ECTL_GETSTRING с -1.</P>

<p class=plain>
Следует заметить, что этот метод требует запоминания текущей позиции
в редакторе и ее восстановления при откате. Но дело того стоит. Итак, код
приведенный выше следует переписать следующим образом:</P>

<PRE class=code>{
    struct EditorGetString egs;
    struct EditorSetPosition esp;
    struct EditorInfo ei;

    Info.EditorControl(ECTL_GETINFO,&ei);
    egs.StringNumber=-1;

    for( esp.CurLine=ei.CurLine;
         esp.CurLine&lt;ei.TotalLines;
         esp.CurLine++ )
    {
        Info.EditorControl(ECTL_SETPOSITION,&esp);
        Info.EditorControl(ECTL_GETSTRING,&egs);
        if( process( egs.StringText, egs.StringLength ) )
            return TRUE; // Успех. Строка уже установлена.
    }

    // восстановим старую позицию:

    esp.CurLine=ei.CurLine;
    esp.CurPos=ei.CurPos;
    esp.TopScreenLine=ei.TopScreenLine;
    esp.LeftPos=ei.LeftPos;
    esp.CurTabPos=-1;
    esp.OverType=-1;
    Info.EditorControl(ECTL_SETPOSITION,&esp);

    return FALSE;
}</PRE>

<p class=plain>
Следует отметить, что FAR не отрисовывает изменения немедленно,
так что "мельтешения" на экране не будет.</p>

<p class=plain>
Теперь о приятном: замеры времени на моей машине показали
ускорение взятия строки (только взятие, без обработки - чистое время)
во втором случае по сравнению с первым в 63 раза. Причем эффект стабилен
как для относительно небольших файлов, так и для файлов в половину и более
моего RAM. Данные Андрея Третьякова примерно те же - у него соотношение 1/65.
Т.е. цифры весьма близкие.</P>

<div class=descr>
Для замера был использован run-time профилировщик Watcom C 11.0 на основе
профилировочной инструкции Pentium <code>rdtsc</code>. IMHO самый правильный
профайлер. Но даже на глаз ускорение <strong>очень</strong> заметно. Моя
конфигурация: IP-240, 96M RAM, Windows NT 4.0 SP6. Андрей Третьяков проводил
испытания на 486-dx4-100.
</div>


<p class=plain>
<b>Небольшое предостережение:</b> при установке позиции FAR может изменить
значения LeftPos, TopScreenLine, CurPos даже если вы использовали для
них -1. Например, если курсору запрещено перемещаться за конец строки, а
строка короче, чем CurPos, который вы пытаетесь сохранить, устанавливая
в -1, то CurPos, тем не менее, изменится. В большинстве случаев такое поведение
вполне удовлетворяет пользователя. Однако, при последовательном переборе строк в
приведенном цикле, пользователь не видит промежуточных перемещений по тексту и будет
удивлен, увидев не совсем ту позицию на экране, на которую он мог бы
рассчитывать при перемещении (с его точки зрения), например, с 1-ой на 10-ю
строку.  В  первом  приведенном  примере  такой проблемы возникнуть не
может,  т.к.  реально  также  осуществляется  только одно перемещение.
Второй  же пример следует модифицировать таким образом, чтобы избежать
подобной проблемы.</P>

<p class=plain>
Вариантов модификации может быть много. Например, если ваш плагин
вообще никогда не меняет текущую позицию (т.е. всегда ее восстанавливает),
то этой проблемы не будет. Если плагин имеет код вычисления TopScreenLine,
LeftPos, CurPos исходя из каких-то своих соображений, возможно вообще не
относящихся к предыдущему их состоянию, то он просто вызовет этот код после
завершения цикла. В моем случае, я всегда восстанавливаю сохраненную позицию,
а уже затем использую <a href="../service_functions/editorcontrol.html#ECTL_SETPOSITION">ECTL_SETPOSITION</a>,
передавая в нее нужную мне строку и -1 для остальных параметров. Вот пример
модифицированного кода:</P>
<PRE class=code>{
    struct EditorGetString egs;
    struct EditorSetPosition esp;
    struct EditorInfo ei;
    int    nFound=-1; // номер найденной строки

    Info.EditorControl(ECTL_GETINFO,&ei);
    egs.StringNumber=-1;

    for( esp.CurLine=ei.CurLine;
         esp.CurLine &lt; ei.TotalLines;
         esp.CurLine++ )
    {
        Info.EditorControl(ECTL_SETPOSITION,&esp);
        Info.EditorControl(ECTL_GETSTRING,&egs);
        if( process( egs.StringText, egs.StringLength ) ){
            nFound=esp.CurLine; // Успех
            break;
        }
    }

    // восстановим старую позицию:

    esp.CurLine=ei.CurLine;
    esp.CurPos=ei.CurPos;
    esp.TopScreenLine=ei.TopScreenLine;
    esp.LeftPos=ei.LeftPos;
    esp.CurTabPos=-1;
    esp.OverType=-1;
    Info.EditorControl(ECTL_SETPOSITION,&esp);

    if( nFound &gt;= 0 )
    {               // А теперь снова установим на найденное место...
        esp.CurLine=nFound;
        esp.CurPos=-1;          // Невзирая на то, что эти поля уже
        esp.TopScreenLine=-1;   // содержат значения - их надо выставить
        esp.LeftPos=-1;         // в -1. Это не одно и то же! Явное число -
        esp.CurTabPos=-1;       // безусловно. -1 лишь _пытается_ сохранить
        esp.OverType=-1;        // старое значение, если это возможно!

        Info.EditorControl(ECTL_SETPOSITION,&esp);
    }

    return nFound &gt;= 0;
}</PRE>


<div align=right><code>
<br>&nbsp;<br>
28.11.1999<br>
Rev. 26.06.2000
</code></div>
<div class=seecont><a href="#top">наверх</a></div>

</body>
</html>