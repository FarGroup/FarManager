<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0060)http://www.programme.ru/index.phtml?arch/102001/102001_1.htm -->
<html>

<head>
<title>Паковать или не паковать? - Журнал &quot;Программист&quot;</title>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<meta http-equiv="Content-Language" content="ru">
<link rel="stylesheet" type="text/css" href="../../../styles/styles.css">
</head>

<body>

<a name="top"></a>
<h1>Паковать или не паковать?</h1>
<div class=navbar>
<a href="../../index.html">главная</a> |
<a href="../index.html">статьи</a>
</div>

<div align=right><code>
Крис Касперски <a href="mailto:kk@sendmail.ru">
<img src="../../../images/email.gif" border="0" alt="[kk@sendmail.ru]" width="16" height="16" align="middle">kk@sendmail.ru</a>
<br>Оригинал: <a href="http://www.programme.ru/index.phtml?arch/102001/102001_1.htm">http://www.programme.ru/index.phtml?arch/102001/102001_1.htm</a>
</code></div>
<hr color="#003399">

<p align="right"><i>&quot;Умный человек, - это тот
человек, который сознает несовершенство,
незакончен-<br>
ность своих знаний, стремится их пополнить
и в этом преуспевает&quot;<br>
Братья Стругацкие &quot;Гадкие лебеди&quot;</i></p>
<p align="justify"></p>
<h2 align="justify">Введение. Царство MS-DOS&nbsp;</h2>
<p align="justify">В те далекие времена, когда объем
жестких дисков (в просторечии - винчестеров)
измерялся мегабайтами - этих мегабайт
всегда не хватало, и большинство файлов (особенно
редко используемых) хранили в упакованном
виде. Перед запуском файл распаковывали, а
после завершения работы - упаковывали вновь,
чтобы освободить место для распаковки
других.</p>
<p align="justify">Когда эти махинации всем
окончательно надоели, программисты (вспомнив,
что компьютер должен служить человеку, а не
наоборот), додумались до автоматической
распаковки исполняемых файлов &quot;на лету&quot;.
Идея заключается в дописывании к сжатому
файлу крохотного распаковщика, которому
передается управление при запуске файла, и
который распаковывает исполняемый код не
на диск, а непосредственно в оперативную
память. Конечно, время загрузки ощутимо
увеличивалось (особенно на машинах с
медленными процессорами), но это с лихвой
окупалось простотой запуска и экономией
дискового пространства.</p>
<p align="justify">Вскоре упаковщиков развелось
видимо-невидимо (их тогда писали все, кому
не лень) - AINEXE, DIET, EXEPACK, LZEXE, PKLITE и масса других
- всех не перечислить! И не удивительно:
процессоры день ото дня становились все
производительнее - уже на &quot;трешке&quot;
распаковка занимала столь незначительное
время, что им можно было пренебречь. К тому
же приятным побочным эффектом оказалась
защита от дизассемблирования.
Действительно, непосредственно
дизассемблировать упакованный файл
невозможно - прежде его необходимо
распаковать. Конечно, на каждый щит
найдется свой меч - из под пера хакеров
вышло немало замечательных универсальных
распаковщиков (UNP, Intruder, UUP, а вершиной всему
стал CPU386 со встроенным эмулятором
реального режима процессора 80386), но
качество автоматической распаковки
оставляло желать лучшего (порой
распакованные файлы зависали при запуске
или в процессе работы), а ручной
трассировкой владели далеко не все.</p>
<p align="justify">Словом, при всех своих
достоинствах, упаковка исполняемых файлов
не имела никаких недостатков и не
собиралась сдавать позиций даже с приходом
емких (по тем временам) одно-двух
гигабайтных жестких дисков и CD-ROM.</p>
<h2 align="justify">Сжатие файлов под Windows 9x\NT</h2>
<p align="justify">Наступил девяносто пятый год -
мир медленно, но неотвратимо пересаживался
на новую операционную систему - Windows 95.
Пользователи осторожно осваивали мышь и
графический интерфейс, а программисты тем
временем лихорадочно переносили старое
программное обеспечение на новую платформу.
Объемы винчестеров к тому времени выросли
настолько, что разработчики могли забыть
слово &quot;оптимизация&quot;, да они, судя по
размеру современных приложений, его и
забыли. Сто мегабайт - туда, триста сюда -
эдак никаких гигабайт не хватит!</p>
<p align="justify">Вот тут-то и вспомнили о
распаковке исполняемых файлов &quot;на лету&quot;.
На рынке появилось несколько программ -
компрессоров, из которых наибольшую
популярность завоевал ASPack, умеющий сжимать
и разжимать не только &quot;экзешники&quot;, но и
динамические библиотеки. А в состав самой
Windows 95 вошла динамическая библиотека LZEXPAND.DLL,
поддерживающая базовые операции упаковки-распаковки
и &quot;прозрачную&quot; работу со сжатыми
файлами. Пользователи и программисты не
замедлили воспользоваться новыми
средствами, но...</p>
<p align="justify">...в отличие от старушки MS-DOS, в Windows
9x\NT за автоматическую распаковку
приходится платить больше, чем получать
взамен. Вспомним, как в MS-DOS происходила
загрузка исполняемых модулей. Файл целиком
считывался с диска и копировался в
оперативную память, причем наиболее узким
местом была именно операция чтения с диска.
Упаковка даже ускоряла загрузку, ибо
физически читался меньший объем данных, а
их распаковка занимала пренебрежимо
короткое время.</p>
<p align="justify">В Windows же загрузчик читает лишь
заголовок и таблицу импорта файла, а затем
проецирует его на адресное пространство
процесса так, будто бы файл является частью
виртуальной памяти, хранящейся на диске. (Вообще-то,
все происходит намного сложнее, но не будем
вдаваться в подробности, не относящиеся к
делу). Подкачка с диска происходит
динамически - по мере обращения к
соответствующим страницам памяти, причем
загружаются только те из них, которые
действительно нужны.</p>
<p align="justify">Например, если в текстовом
редакторе есть модуль работы с таблицами,
он не будет загружен с диска до тех пор, пока
пользователь не захочет создать (или
отобразить) свою таблицу. Причем неважно -
находится ли этот модуль в динамической
библиотеке или в основном файле! (Вот и
попробуйте после этого сказать, что Windows
глупые люди писали!) Загрузка таких &quot;монстров&quot;,
как Microsoft Visual Studio и Word, как бы &quot;размазывается&quot;
во времени и к работе с приложением можно
приступать практически сразу же после его
запуска. А что произойдет, если файл
упаковать? Правильно - он будет должен
считаться с диска целиком (!) и затем - опять-таки,
целиком - распаковаться в оперативную
память.</p>
<p align="justify">Стоп! Откуда у нас столько
оперативной памяти? Ее явно не хватит и
распакованные страницы придется вновь
скидывать на диск! Как говорится: за что
боролись, на то и напоролись. Причем, если
при проецировании неупакованного exe-файла
оперативная память не выделяется, (во
всяком случае, до тех пор, пока в ней не
возникнет необходимость), распаковщику без
памяти никак не обойтись! А поскольку
оперативной памяти никогда не бывает в
избытке, она может быть выделена лишь за
счет других приложений! Отметим также, что в
силу конструктивных особенностей железа и
архитектуры операционной системы, операция
записи на диск заметно медленнее операции
чтения.</p>
<p align="justify">Важно понять: Windows никогда не
сбрасывает на диск не модифицированные
страницы проецируемого файла. Зачем ей это?
Ведь в любой момент их можно вновь считать
из оригинального файла. Но при распаковке
модифицируются все страницы файла! Значит,
система будет вынуждена &quot;гонять&quot; их
между диском и памятью, что существенно
снизит общую производительность всех
приложений в целом.</p>
<p align="justify">Еще большие накладные расходы
влечет за собой сжатие динамических
библиотек. Для экономии памяти страницы,
занятые динамической библиотекой
совместно используются всеми процессами,
загрузившими эту DLL. Но как только один из
процессов пытается что-то записать в память,
занятую DLL, система мгновенно создает копию
модифицируемой страницы и предоставляет ее
в &quot;монопольное&quot; распоряжение процесса-писателя.
Поскольку распаковка динамической
библиотеки происходит в контексте процесса,
загрузившего ее, система вынуждена
многократно дублировать все страницы
памяти, выделенные библиотеке, фактически
предоставляя каждому процессору свой
собственный экземпляр DLL. Предположим, одна
DLL размером в мегабайт, была загружена
десятью процессами - посчитайте: сколько
памяти напрасно потеряется, если она сжата!</p>
<p align="justify">Таким образом, под Windows 9x\NT
сжимать исполняемые файлы нецелесообразно
- вы платите гораздо больше, чем выручаете.
Что же касается защиты от
дизассемблирования: Да, когда ASPack только
появился, он отвадил от взлома очень многих
неквалифицированных хакеров, но - ненадолго!
Сегодня в сети только слепой не найдет
руководство по ручному снятию ASPack'а.
Существует и масса готового инструментария
- от автоматических распаковщиков до
плагинов к дизассемблеру IDA Pro, позволяющих
ему дизассемблировать сжатые файлы.
Поэтому, надеяться, что ASPack спасет вашу
программу от взлома, несколько наивно.</p>
<h2 align="justify">Точные цифры</h2>
<p align="justify">В заключение поговорим об
измерении падения производительности от
упаковки файлов. Казалось бы, что тут
сложного - берем неупакованный файл,
запускаем его, замеряем время загрузки,
записываем результат на бумажке,
упаковываем, запускаем еще раз, и...</p>
<p align="justify">Первый камень преткновения - что
понимать под &quot;временем загрузки&quot;? Если
проецирование - так оно выполняется
практически мгновенно, и им можно вообще
пренебречь. Моментом времени, начиная с
которого с приложением можно полноценно
работать? Так это от самого приложения
зависит больше, чем от его упаковки. К тому
же, на время загрузки упакованных файлов
очень сильно влияет количество свободной
на момент запуска физической оперативной
памяти (не путать с общим объемом памяти,
установленной на машине). Если перед
запуском упакованного файла мы завершим
одно-два &quot;монстроузных&quot; приложения, то
занятая ими память окажется свободной, и
сможет беспрепятственно использоваться
распаковщиком. Напротив, если свободной
памяти нет, ее придется по крохам отрывать
от остальных приложений...</p>
<p align="justify">Даже если мы оценим изменение
времени загрузки (что, кстати, сделать
весьма проблематично - серия замеров на
одной и той же машине, с одним и тем же
набором приложений дает разброс
результатов более чем на порядок), как
измерять падение производительности
остальных приложений? Ведь, при нехватке
памяти Windows в первую очередь избавляется от
не модифицированных страниц, которые
незачем сохранять на диске! В результате
упаковка исполняемого файла может
несколько повысить производительность
самого этого файла, но значительного
ухудшить положение остальных,
неупакованных приложений!</p>
<p align="justify">Поэтому никаких конкретных цифр
в статье не приводится. Приблизительные
оценки, выполненные &quot;на глаз&quot;,
показывают, что при наличии практически
неограниченного количества оперативной
памяти потери производительности
составляют менее 10%, но при ее нехватке
скорость всех приложений падает от двух до
десяти раз! (Для справки: в эксперименте
участвовали исполняемые файлы MS Word 2000, Visual
Studio 6.0, Free Pascal 1.04, IDA Pro 4.17, Adobe Acrobat Reader 3.4,
машина с процессором CLERION-300A, оснащенная 256
МБ ОЗУ, для имитации нехватки памяти ее
объем уменьшался до 64 МБ; использовались
операционные системы Windows 2000 и Windows 98).</p>
<h2 align="justify">Выводы:</h2>
<ol>
<li>Исполняемые файлы под Windows
лучше не паковать. В крайнем случае -
используйте для упаковки/распаковки
функции операционной системы (LZInit, LZOpenFile,
LZRead, LZSeek, LZClose, LZCopy), динамически
распаковывая в специально выделенный буфер
только те части файла, которые
действительно нужны в данный момент для
работы.</li>
<li>Динамические библиотеки вообще
не следует паковать, ибо это ведет к
чудовищному расходу и физической, и
виртуальной памяти и извращает саму
концепцию DLL - один модуль - всем процессам.</li>
<li>Кстати, о динамических
библиотеках: не стремитесь кромсать свое
приложение на множество DLL - страницы
исполняемого файла не требуют физической
памяти до тех пор, пока к ним не происходит
обращений. Поэтому - смело помещайте весь
код программы в один файл.</li>
</ol>

</body>

</html>
