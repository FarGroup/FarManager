<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<title>Отладка плагинов в Borland Turbo Debugger</title>
<meta http-equiv="Content-Type" Content="text/html; charset=Windows-1251">
<link rel="stylesheet" type="text/css" href="../../styles/styles.css">
</head>
<!--
	History of modification:
	Date: Dec 24 2000 by slava@baltica.ru

	Todo:
		examples/success stories
		useful hints
		more info refs
		как ставить брякпоинты в исходнике до сборки
        OEM в TD?
-->
<body>

<a name="top"></a>

<h1>Отладка плагинов в Borland Turbo Debugger</h1>
<div class=navbar>
<a href="../index.html">главная</a> |
<a href="index.html">статьи</a>
</div>

<div align=right><code>
Вячеслав Печенин <a href="mailto:Slava%20Pechenin%20<slava@baltica.ru>?subject=Articles">
<img src="../../images/email.gif" border="0" alt="[slava@baltica.ru]" width="16" height="16" align="middle">slava@baltica.ru
</a></code></div>
<hr color="#003399">

<p class=plain>
Borland Turbo Debugger (далее TD) - бесплатная альтернатива встроенным
отладчикам из коммерческих сред разработки (e.g., MSVC или BCB).
Скачать можно <a href="ftp://ftpd.inprise.com/download/bcppbuilder/TurboDebugger.exe">здесь</a>.
</p>

<h2>Замечания</h2>

<p class="plain">
1. TD поможет отладить только то, что получено компилятором BCC 5.5
(взять можно <a href="ftp://ftpd.inprise.com/download/bcppbuilder/freecommandLinetools.exe">здесь</a>, патчи <a href="http://www.borland.com/devsupport/bcppbuilder/patches/#freecompiler55">здесь</a>).
</p>

<p class=plain>
2. TD - консольное приложение (удивляться этому особенно не нужно; Far, если
вы заметили, тоже не особенно GUI) для отладки только Win32 приложений. И тем не менее
совсем не дружит с кодовой страницей OEM (<a href="#oem">см.подробнее</a>). По сему применять этот отладчик
сложнее, чем интегрированные в IDE.
</p>

<a name="c1"></a>
<h2>Рабочий цикл отладки</h2>

<p class="plain"><a href="#p1">
1) Сборка .DLL, включая отладочную информацию.</a></p>

<p class="plain"><a href="#p2">
2) Открываете хост-приложение FAR.EXE</a></p>

<p class="plain"><a href="#p3">
3) Обращаете внимание TD на вашу .DLL</a></p>

<p class="plain"><a href="#p4">
4) Ставите breakpoints.</a></p>

<p class="plain"><a href="#p5">
5) На остановках делаете дело.</a></p>

<br>

<a name="p1"></a>
<h3>1) Сборка</h3>
<p class=plain><em>Компилятор</em>.
Нужно, чтобы BCC поместил в результат debug info и line info. Первое
включено по умолчанию (или "-v" для параноиков), второе включается руками
"-y".</p>

<p class=plain>
<em>Редактор связей</em>.
Он по умолчанию помещает в результат только самое нужное. Чтобы Debug info
попало в эту категорию используйте ключик "-v".</p>

<p class=plain>
<em>Итого:</em><br>
bcc32 -c -v -y Hello.cpp<br>
ilink32 -Tpd -v c0d32.obj Hello.obj,Hello.dll,,cw32.lib import32.lib
</p>

<br><br>

<a name="p2"></a>
<h3>2) Запускаем хост приложение под TD</h3>
<p class=plain>
Перед тем, как запускать TD, не забудьте, что FAR.EXE должен будет по
ходу дела подгрузить вашу .DLL как плагин. Поместите вашу .DLL и .TDS
файлик куда нужно. .TDS ссылается на ваши исходники, которые TD найдет
там, куда укажет ключик "-sd".</p>

<p class=plain>
Также неплохо, чтобы TD текущей директорией сделал ту, где лежит .DLL,
которую подхватит FAR.EXE. Ключик "-t".</p>

<p class="plain">
<em>Итого:</em><br>
td32 -sd"C:\Hello Plugin\Source" -t"C:\Program files\Plugins\Hello" "C:\Program files\Far\Far.exe"
</p>

<br><br>

<a name="p3"></a>
<h3>3) Остановка "entry point"</h3>
<p class="plain">
TD остановится с сообщением, что FAR.EXE не содержит debug info. Это -
правда. Да и хорошо, что остановится: время предупредить TD, чтобы сделал позже еще одну остановку -
тогда проставим breakpoints в HELLO.DLL.<p>

<p class="plain">
Давим F3 (меню VIEW->MODULE...).
</p>

<p class="plain">
В поле "DLL name" можно ввести:
	"hello"
	или "hello.dll"
	или даже "c:\path\hello.dll" (если ключик "-t" вы не захотели TD
	указать).
</p>

<p class="plain">
Жмите "Add DLL", не стесняйтесь.
</p>

<div align="center">
	<br>
	<img src="../../images/td1.gif">
	<br><br>
</div>

<p class="plain">
Больше этот диалог не нужен. ESC на него. И продолжим - F9 (Run->Run).
<p>

<p class="plain">
Вопрос: зачем же руками TD сообщать о DLL, которую чуть позже FAR.EXE загрузит?
</p>
<p class="plain">
Ответ: а за тем, что TD выставил флажок "debug startup" (посмотрите сами), и
сделает нужную нам остановку, когда FAR.EXE действительно подгрузит HELLO.DLL
</p>

<br><br>

<a name="p4"></a>
<h3>4) Breakpoints</h3>

<p class="plain">
TD остановится на входе в HELLO.DLL</p>

<p class="plain">
Ба-а-а, что же мы видим -
дизассемблерованный код. Зачем он нам, какой от него толк? Не все сразу,
потерпите.
</p>

<p class="plain">
Давим F3.
</p>

<p class="plain">
HELLO.DLL -> "Symbol load" (вот и пригодился .TDS файлик)
</p>
<p class="plain">
Oops, диалог пропал. А ничего не произошло.
</p>
<p class="plain">
Давим опять F3. И видим, что не зря только что диалог пропадал:
</p>

<div align="center">
	<br>
	<img src="../../images/td2.gif">
	<br><br>
</div>

<p class="plain">
Список "Source modules" пополнился. Выбираешь модуль, давишь "Load" и попадаешь в его
исходник, все логично. А попав в исходник, не теряйся, ставь breakpoint.
</p>

<p class="plain">
Замечания.
</p>

<p class="plain">
* Временами попав в исходник, TD не дает поставить breapoint.
Тогда нужно сходить в меню VIEW->VARIABLES и найти нужную ф-цию там.
</p>
<p class="plain">
** Все расставленные остановки сохранятся в .TR2, который как-то связывается с .TDS. Так что пересобрав
.DLL, а значит получив новый .TDS, или удалив .TR2 - вы потеряете всю информацию об остановках. И все с начала...
</p>


<br><br>

<a name="p5"></a>
<h3>5) Отладка</h3>

<p class="plain">
Здесь все делается, как обычно в инструментах от Borland. Единственно,
что я для себя с удивлением открыл: неутомимый "Inspect" - можно встать курсором на символьном
имени и правой кн. мыши проинспектировать, а там опять же можно проинспектировать и т.д.
</p>

<p class="plain">
Трассировать можно с легкостью по исходнику. Можно по дизассембл. коду.
Однако, если вы хотите шагнуть F7 за пределы своей .DLL, то нужно
переключиться в ассебл. вид.
</p>

<a name="oem"></a>
<p class="plain">
Будучи консольным приложением TD показывает все строчки в ANSI. Это не значит для
плагинописания ничего хорошего, ведь Far и плагины, следуя его правилам, все показывает в OEM.
Как победить TD в этом вопросе - я не знаю. Небольшой совет: в
диалоге Evaluate/Modify (@F4) введите "lpstr[0],c10" и увидите свою строчку в OEM. Этот же фокус
поможет для Watch. А для Inspect не поможет.
</p>

<br><br>

<a name="c2"></a>
<h2>Заключение</h2>

<p class="plain">
Самое интересное, что несмотря на рутинную ботву в работе с TD, я им
пользуюсь. Потому что:
<ul>
	<li>
	TD - полностью удовл. нужды в отладке.
	</li>
	<li>
	TD - это продукт традиционно высокого качества от Borland.
	</li>
	<li>
	TD - бесплатный.
	</li>
</ul>
</p>

<br><br>

<a name="c3"></a>
<h2>Дополнительные источники</h2>
<ul>
	<li>
	<a href="http://www.borland.com/bcppbuilder/freecompiler/">Официальная страница Borland про компилятор BCC</a>
	</li>
	<li>
	<a href="http://www.borland.com/bcppbuilder/turbodebugger/">Официальная страница Borland про отладчик TD</a>
	</li>
	<li>
	<a href="news://forums.inprise.com/borland.public.cppbuilder.commandlinetools">Ньюсгруппа, посвященная BCC 5.5</a>
	</li>
</ul>

<div align=right><code>
<br>&nbsp;<br>
Rev. 24.12.2000
</code></div>
<div class=seecont><a href="#top">наверх</a></div>

</body></html>
