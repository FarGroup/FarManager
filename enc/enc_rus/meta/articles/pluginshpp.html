<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<title>Корректировка PLUGIN.HPP</title>
<meta http-equiv="Content-Type" Content="text/html; charset=Windows-1251">
<LINK REV=made href="mailto:vskirdin@mail.ru">
<META NAME="Author"   content="Valentin Skirdin">
<META NAME="description" CONTENT="Корректировка PLUGINS.HPP">
<link rel="stylesheet" type="text/css" href="../../styles/styles.css">
<script language="JavaScript" src='../links.js' type="text/javascript"></script>
</HEAD>

<Body>

<a name=top></a>
<h1>Корректировка PLUGIN.HPP</h1>
<div class=navbar>
<a href="../index.html">главная</a> |
<a href="index.html">статьи</a>
</div>

<div align=right>
<code>Валентин Скирдин <a href="mailto:Valentin%20Skirdin%20<vskirdin@mail.ru>?subject=Articles">
<img src="../../images/email.gif" border="0" alt="[vskirdin@mail.ru]" width="16" height="16" align="middle">vskirdin@mail.ru</a>
</code></div>
<hr color="#003399">

<p class=note><img src="../../images/note.gif" alt="Замечание" width="10" height="10"> Замечание</p>
<UL class=note><LI>Материал данной статьи потерял всякую актуальность с выходом
FAR Manager 1.70.1 (указанные HPP-файлы уже входят в дистрибутив в описываемом
виде), но оставлен в качестве учебного пособия.
</LI></UL>

<p class=plain>Всем, кто хоть раз пробовал писать плагины для FAR Manager,
известен заголовочный файл <b>PLUGIN.HPP</b> (его можно найти здесь:
<code>%FAR%\PlugDoc.rar:plugin.hpp</code> - <em>ред: начиная с FAR 1.70 beta 5 примеры
устанавливаются в отдельный каталог PlugDoc</em>). Но, к сожалению (с моей точки
зрения), это чистой воды полуфабрикат. Здесь я предлагая некоторые
"доработки" этого заголовочного файла, т.с. приведение содержимого файла
к некоему стандарту. Доработок совсем немного, но эти доработки
(IMHO) весьма полезные.</p>


<p class=plain>
Первое, что мы сделаем - исключим повторную прекомпиляцию PLUGIN.HPP
(это тот этап, на котором компилятор наполняет свои внутренние таблицы
информацией из C/CPP и H/HPP -файлов - имена, типы, and etc.). Для этого
достаточно в начало PLUGIN.HPP следующие строки:
</p>

<pre class=code>#ifndef __PLUGIN_HPP
#define __PLUGIN_HPP

//#include &lt;windows.h&gt;
</pre>

<p class=plain>
...а самой последней строкой поставить:
</p>

<pre class=code>#endif // __PLUGIN_HPP
</pre>



<p class=plain>
На втором этапе внесем некоторые коррекции для директив компиляции, с учетом
знаний о компиляторе <a target="_blank" href="http://www.cs.virginia.edu/~lcc-win32/" target="_blank"
title="LCC-Win32 is a free (note not 'public domain') C compiler system for Windows 95/98 and Windows NT.">LCC-Win32</a>...
<pre class=code>...
#elif defined(__GNUC__) || (defined(__WATCOMC__) && (__WATCOMC__ &lt; 1100))<b> || defined(__LCC__)</b>
  #pragma pack(1)
<b>  #if defined(__LCC__)
    #define _export __declspec(dllexport)
  #endif</b>
#else
...</pre>

<p class=plain>
...в конце необходимо тоже внести изменения:
</p>

<pre class=code>...
#elif defined(__GNUC__) || (defined(__WATCOMC__) && (__WATCOMC__ &lt; 1100))<b> || defined(__LCC__)</b>
  #pragma pack()
#else
...</pre>


<p class=plain>
Третий этап - перечислим <u>прототипы</u> всех экспортируемых API-функций.
Но сделаем это несколько необычно - заключим прототипы в "скобки" (выделено),
а также учтем "пожелания" компилятора LCC-Win32 (по поводу остальных
компиляторов ничего не скажу, т.к. "общался" только с Borland C и LCC-Win32):
</p>

<pre class=code>#if defined(__BORLANDC__)
<b>#ifdef __cplusplus
extern "C" {
#endif</b>

void WINAPI _export ClosePlugin(HANDLE hPlugin);
.
.
.
int WINAPI _export ProcessEditorEvent(int Event,void *Param);

<b>#ifdef __cplusplus
};
#endif</b>
#endif</pre>


<p class=plain>
Многие компиляторы, встретив файл с расширением CPP, переключаются в режим
С++. А в этом режиме, как известно, имена функций "коверкаются" компилятором
с тем, чтобы была возможность перегрузки имен функций (<small>более детальную
информацию по этому вопросу смотрите в учебниках по С++ - например
<a target="_blank" href="http://www.citforum.ru/programming/index.shtml">здесь</a></small>). Но так, как FAR Manager ожидает от нашего
плагина вполне конкретные имена функций, то...
</p>

<p class=plain>
И, напоследок, скопируем полученный файл PLUGIN.HPP в каталог INCLUDE с
тем, чтобы не размножать на диске копии этого файла, а просто взять и
в исходнике написать:
</p>
<pre class="code">
#include &lt;plugin.hpp&gt;
</pre>

<p class=plain>
Кстати, тоже самое проделайте и с FMT.HPP (если, конечно, пишите плагины
второго уровня для плагина MultiArc)
</p>

<div align=right><code>
<br>&nbsp;<br>
02.01.2000<br>Rev 13.02.2000</code></div>

<div class=seecont><a href="#top">наверх</a></div>

</body>
</html>