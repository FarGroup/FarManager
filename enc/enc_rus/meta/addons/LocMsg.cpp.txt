/*
LocMsg - Скажем локализации: "ДА!"
Author - Ivan Sintyurin. Copyright (c) 2000. All Rights Reserved.

  Я буду рад, если данная функция поможет Вам писать программы  с
возможностью локализации. Прошу Вас только об одном -  указывайте
мой copyright (в readme, например).

  Функция LocMsg возвращает указатель на строку в соответствие  с
языковыми  настройками  FAR'а  (учитывает  настройки   конкретных
пользователей - фича FAR 1.63).

  В каталоге с плагином должен быть файл с сообщениями  с  именем
"ИмяПлагина.msg" Описание формата находится в файле template.msg.

Передаваемые параметры:
MsgName - название нужного сообщения
Var     - если не NULL, то сюда копируется полученная строка
Len     - если = 0, то копируется столько, сколько есть

Должна также быть определена и заполнена глобальная структура
PluginStartupInfo Info, из нее берутся данные:
Info.RootKey - место, где хранятся данные плагинов
Info.ModuleName - полный путь к плагину
*/
char *LocMsg(struct PluginStartupInfo *psi,char *MsgName, char *Var,int Len)
{
  HKEY hKey;
  DWORD Type;
  static char Msg[81];
  char *ppMsg;
  char *sLanguage="Language", *smsg=".msg", *sRussian="Russian";
  char msgfile[NM],       //имя файла с данными
       Lang[80],                //Название языковой секции, по умолчанию=Russian
       LangKey[80]="";    //Языковые настройки FAR'а

  lstrcpy(msgfile,Info.ModuleName);//Определяем имя файла
  lstrcpy(Lang,sRussian);
  char *ptr=strrchr(msgfile,'.');  //с сообщениями.
  if(ptr) lstrcpy(ptr,smsg);     //У Вас это может
  else lstrcat(msgfile,smsg);    //выглядеть иначе.

  lstrcat(LangKey,Info.RootKey);//Определяем:
  ptr=strrchr(LangKey,'\\');    //откуда читать
  lstrcpy(ptr+1,sLanguage);    //языковые настройки.

  //Читаем языковые настройки текущего пользователя
  if(RegOpenKeyEx(HKEY_CURRENT_USER,LangKey,0,KEY_READ,&hKey)==ERROR_SUCCESS)
  {
          DWORD DataSize=80;
          RegQueryValueEx(hKey,"Main",NULL,&Type,(BYTE *)&Lang,&DataSize);
          RegCloseKey(hKey);
  }

  if(!GetPrivateProfileSection(Lang,Msg,80,msgfile))
  {
          //если требуемой секции нет, то прочитать имя секции по умолчанию
          GetPrivateProfileString("Default",sLanguage,sRussian,Lang,80,msgfile);
          if(!GetPrivateProfileSection(Lang,Msg,80,msgfile))
                  //если нет требуемой секции с именем=имя по умолчанию
                  //то читать будем первую попавшуюся секцию
                  GetPrivateProfileSectionNames(Lang,80,msgfile);
  }

  if(!Var)
    ppMsg=Msg;
  else
    ppMsg=Var;

  if(!Len)
    Len=80;
  Len++;
  //читаем нужную строку
  GetPrivateProfileString(Lang,MsgName,MsgName,ppMsg,Len,msgfile);

  //Если раскомментировать следующую строку, то в msg-файле будут
  //автоматически создаваться отсутствующие секции
  //if(lstrcmp(MsgName,Msg)==0)
  //  WritePrivateProfileString(Lang,MsgName,Msg,msgfile);

//  if(Var)
//    lstrcpy(Var,Msg);//Копируем в Var полученную строку, если надо
  return(ppMsg);
}
